Работа с процессами (jobs, bg, fg) 
###############################################

:date: 2022-03-19 15:20
:summary:  Работа с процессами (jobs, bg, fg) 
:status: published
:author: Шатров П.А., обновлено: Бестужева С.А.


.. contents:: Содержание

**Теоретическое введение** 
============================
Программа представляет собой серию инструкций, которая указывает компьютеру, что делать. Запущенный экземпляр программы называется процессом, которым мы управляем.
Linux,  как и большинство современных ОС, является многозадачной операционной системой. Это означает, что многие процессы могут выполняться одновременно. 
Наряду с процессами, которые мы запускаем, в системе могут быть и другие пользователи.

**fg, bg и jobs**
============================
Запущенный процесс в обычном режиме работает в режиме «foreground«, т.е. — «на переднем плане» или, другими словами, «в приоритетном режиме». 
В таком режиме он принимает команды с управляющего терминала, в котором он запущен, и на него же выводит информацию. Кроме того, он делает недоступным командную строку. 
Для прекращения процесса "на переднем плане" необходимо нажать сочетание клавиш **CTRL+C**.
Может быть, мы хотим запустить процесс, который займет немного времени и с радостью сделает это без нашего вмешательства. Например, обработка очень большого текстового файла.
Тогда, мы можем запустить программу в фоновом режиме, а затем продолжить работу. Командная строка при этом станет доступна, но оставаясь в том же окне 

Что бы запустить задачу в фоновом режиме — в конце команды необходимо добавить знак **&**
Отобразить список текущих фоновых задач можно командой **jobs**
(**jobs** — показать список текущих заданий, работающих в фоновом режиме.)

Либо — запустить её в обычном режиме, после чего нажать комбинацию **CTRL+Z**, отправив ей сигнал **TSTR** (сигнал остановки, генерируемый клавиатурой. 
Переводит процесс в фоновый режим). После этого — она появится в списке **jobs** с новым номером. При этом на экране, например, появится следующее сообщение:
::

    [1]+  Остановлен    ./a.sh 2

Теперь, что бы продолжить её выполнение в фоновом режиме необходимо ввести команду **bg** (background).
У задач в фоне имеется собственный номер, который всегда начинается с единицы (если нет других фоновых задач). 
Кроме того, **jobs** отображает состояние процесса — Running (Запущен), Stopped (Остановлен), Done (Завершен), Exit. Например, по окончании архивирования — статус задачи станет Done.
((**bg** —  возобновляющийся процесс продолжает выполняться в фоне без ввода пользователем каких-либо команд с терминала.)
В случае, когда мы имеем несколько задач, и хотим только определенные запустить в фоновом (или же переднем) плане, после соответствующей команды необходимо дописать номер задачи, например:
::

    $bg 1

Если команду **jobs** запустить из каталога отличного от того, в котором была запущена сама задача — **jobs** укажет её **wd** — working directory. 
Так же, необходимо учитывать, что для каждого управляющего терминала номера задач в **jobs** будут независимы и начинаться с единицы.

Что бы вывести задачу из фонового режима — используется команда **fg** (foreground), которой можно либо передать номер задачи в качестве аргумента, 
либо — запустить без аргументов. В последнем случае — будет выведена задача, отмеченная знаком **+** в списке **jobs**, т.е. — последняя отправленная «в фон» задача.
(**fg** — переместить фоновый процесс на передний план.) Например, в случае:
::

    [1]-  Запущен          ./a.sh 2 &
    [2]+  Запущен          ./a.sh 3 &

при вводе "fg" на передний план будет выведена задача с номером 2, а при вводе "fg 1" с номером 1.
Стоит обратить внимание, что если задача выводит некоторые значения и вывод не настроен в другое окно, то в фоновом режиме команды в командной строке будут печататься "поверх". Важно не забывать пробелы и другие важные знаки команды для ее корректной работы. Например, в данном случае запущены программы, печатающие бесконечное количество 2 и 3 (раз в секунду), если мы будем печатать командв медленно, то допустим это может выглядеть следующим образом:
::

    $ 23232323jo23b23s23
    [1]-  Запущен          ./a.sh 2 &
    [2]+  Запущен          ./a.sh 3 &

Если мы хотим увидеть только запущенные программы, необходимо ввести **jobs -r**, тогда остановленные программы не будут показаны. Если остановленные - **jobs -s**.

**Команды для управления процессами**
========================================

**top**
Если мы хотим получить снимок того, что в данный момент происходит в системе, нужно использовать программу **top**.
(**top** - просмотр в режиме реального времени данных о процессах, запущенных в системе.)

**ps**
Другая программа для просмотра процессов называется **ps**, которая обозначает процессы. При обычном использовании покажет вам только процессы, запущенные в вашем текущем
терминале. 
(**ps** — получить список процессов, запущенных в системе.)

**kill**
Мы будем использовать это, чтобы определить, какой процесс отменить. Для этого мы используем программу, которая соответственно называется **kill**. 
Иногда запустив **kill**, процесс будет остановлен и завершен. Когда вы делаете это, **kill** отправляет процессу сигнал, который просит процесс завершиться. 
Мы всегда пробуем эту опцию в первую очередь, это лучший вариант.
(**kill** — завершить запуск процесса.)
Чтобы "убивать" задачи, необходимо знать PID (персональный идентификатор процесса). Один из вариантов сделать это - ввести команду **jobs -l**. Если же мы введем **jobs -p**, то увидим только PID задач.
Чтобы увидеть все возможности **kill**, необходимо ввести **kill -l**. Но на самом деле из этого списка необходимо знать только SIGTERM (15) и SIGKILL (9).

SIGTERM –  Этот сигнал запрашивает остановку процесса который работает. Этот сигнал может быть проигнорирован.Процессу дается время, чтобы хорошо выключился.
Когда программа хорошо выключается, это означает, что ей дано время, чтобы спасти его прогресс и освободить ресурсы. Другими словами, он не «forced» прекращение работы процесса. SIGTERM выполняется по умолчанию при введении kill.

SIGKILL –  сигнал SIGKILL заставляет процесс прекратить выполнение своей работы немедленно. Программа не может игнорировать этот сигнал. Несохраненный прогресс будет потерян.

Выполнение команды:
::
    
    $kill PID

В случае, если по умолчанию задача не убивается можно сделать это следующим образом:
::

    $kill SIGKILL PID

или
::

    $kill -9 PID
  
Здесь "9" - флаг сигнала SIGKILL

Некоторые из наиболее часто используемых сигналов:

1 HUP (hang up) — повесить.

2 INT (interrupt) — прерывание.

3 QUIT (quit) — выход.

6 ABRT (abort) — прерывания.

9 KILL (non-catchable, non-ignorable kill)

14 ALRM (alarm clock) — будильник.

15 TERM (software termination signal) — Программное обеспечение для прекращения сигнала.

В kill можно подавать несколько задач, тогда он будет убивать из по очереди. При этом при введении команды jobs будет отображено: Убито
::

    $ jobs
    [1]-  Убито              ./a.sh 2
    [2]+  Остановлен    ./a.sh 3

Чтобы убить все задачи, есть команда **killall**.
При этом, если после нее ввести допустим "a.sh" - в данном случае название файла со скриптом, то команда убьет все задачи, название которых содержат "a.sh", остальные убиты не будут.

**pkill**
- команда позволяет убивать задачи по названию. Так же, при введении **pkill -u**, а после этого имени пользователя, будут убиты все задачи данного пользователя

**Практическая часть**
============================

1).  Запуск долго исполняющейся команды в фоновом режиме.
Для запуска задачи в фоновом режиме используется символ **&** после имени команды:
::

    $ ping 127.0.0.1 &

Задаче присваивается идентификатор 1, вывод передается через этот же терминал, хотя сама задача исполняется в фоновом режиме, ведь если попытаться завершить
ее исполнение с помощью сочетания клавиш **CTRL+C**, ничего не получится. Также не лишним будет выполнить команду **jobs**, чтобы убедиться в наличии фоновой задачи
(ввиду того, что в примере вывод утилиты передается через тот же терминал, ввод команды будет осложнен): 

::

  $ jobs
    [1]+ Запущен ping 127.0.0.1 &
    
2). Перевод задачи в обычный режим.
Для перевода задачи в обычный режим следует использовать команду **fg**:
::

    $ fg %ping
    ping 127.0.0.1

Здесь в качестве идентификатора задачи было использовано начало команды, хотя можно бы было использовать такие идентификаторы, как **%1**. 
Задача начала исполняться в обычном режиме, поэтому для завершения ее исполнения может использоваться сочетание клавиш **CTRL+C**.

3). Остановка исполнения команды.
::

     ^Z
    [1]+  Stopped    ping 127.0.0.1

Для остановки исполнения команды было использовано сочетание клавиш **CTRL+Z**. В результате а задаче был присвоен идентификатор %1.
В этом достаточно просто убедиться с помощью команды **jobs**:
::

    $ jobs
    [1]+  Stopped    ping 127.0.0.1

4). Возобновление исполнения задачи в фоновом режиме при помощи **bg**.
::

    $ bg %ping
    [1]+ ping 127.0.0.1 &

Для перевода задачи в обычный режим и завершения её исполнения достаточно использовать п.2. Для завершения исполнения задачи использовать сочетание клавиш **CTRL+C**.

5). Просмотр фоновых процессов при помощи **jobs**
Пусть в фоне у нас одновременно работают несколько задач. Мы можем просмотреть список заданий с помощью **jobs**:
::

     $ jobs
     [1]-  Running    ping 127.0.0.1
     [2]+  Running    ping 127.0.0.2

Число в левой колонке — это порядковый номер задания, который bash присваивает ему при запуске. Плюс (+) у второго задания значит, что это «текущее задание»,
оно будет выведено на передний план при вводе fg. Вы также можете вывести на передний план конкретное задание указывая его номер; например, fg 1 
Наконец, состояние обоих процессов «Running» (выполняется) и их командная строка справа. Минус (-) стоит у той задачи, которая станет приоритетной, если задача с плюсом будет прекращена или убита.

**Задачи**
============================

1. Напишите скрипт, выводящий бесконечное количество чисел и запустите его в фоновом режиме, проверьте, что командная строка при этом работает.

2. При помощи одной строки, используя цикл и готовый скрипт, запустите в фоновом режиме вывод бесконечного количества чисел от 1 до 10. 

3. Убейте задачи из пункта 2, отвечающие за 3, 6, 7, 10.

4. Остановите оставшиеся программы, а затем убейте из при помощи killall.



